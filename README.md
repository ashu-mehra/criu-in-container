# criu-in-container-demo

This project is an attempt to demostrate use of CRIU inside docker containers to improve startup time of applications.
It uses AcmeAir Java application as the use-case. You can read more about AcmeAir [here](https://github.com/sabkrish/acmeair).

## AcmeAir execution process

Process for starting AcmeAir involves following steps:

### 1. Clone AcmeAir repository

Check out `microservice_changes` branch from the repository:\
`git clone --depth 1 git@github.com:sabkrish/acmeair.git -b microservice_changes acmeair`

### 2. Install gradle

[Gradle 4.1](https://services.gradle.org/distributions/gradle-4.1-bin.zip)` seems to work fine.

### 3. Build the application

Go to AcmeAir source directory and run `gradle build`.\
This would generate `acmeair-webapp/build/libs/acmeair-webapp-2.0.0-SNAPSHOT.war` on successful completion.

### 4. Create docker images

To generate docker image run following command from the AcmeAir source directory:\
`docker-compose -f docker-compose.yml_monolithic build`

After successful completion, two images `mongo:latest` and `acmeair_mono_service_liberty1` would be generated.\
`mongo:latest` is the mongo-db container image.\
`acmeair_mono_service_liberty1` is the container image for AcmeAir application based on Liberty server

### 5. Create docker network

This is required for communication between mongo-db container and AcmeAir app container.\
Run following command to set-up docker bridge network:\
`docker network create --driver bridge acmeair-net`

### 6. Start the containers

Start the mongo-db container first as:\
`docker run -d --name=acmeair-db --network=acmeair-net mongo`

Next start the AcmeAir application:\
`docker run -d --name=acmeair-server -p 80:80 --network=acmeair-net -e MONGO_HOST=acmeair-db acmeair_mono_service_liberty1`

Verify the AcmeAir started by checking logs of the container as:\
`docker logs -t --follow acmeair-server`

You can check the server logs for the time it took to start the application.\
In the output of above command, search for the message `The server defaultServer is ready to run a smarter planet`.\
The timestamp for this message minus the timestamp for the first message would give you the startup time.

Now you should be able to access `http://localhost/`.

A sample output generated by `docker logs`:
```
$ docker logs -t acmeair-server
2019-03-15T08:19:46.645067700Z 
2019-03-15T08:19:47.235712655Z Launching defaultServer (WebSphere Application Server 19.0.0.2/wlp-1.0.25.cl190220190222-1311) on IBM J9 VM, version 8.0.5.30 - pxa6480sr5fp30-20190207_01(SR5 FP30) (en_US)
2019-03-15T08:19:47.392605173Z [AUDIT   ] CWWKE0001I: The server defaultServer has been launched.
2019-03-15T08:19:47.403278238Z [AUDIT   ] CWWKE0100I: This product is licensed for development, and limited production use. The full license terms can be viewed here: https://public.dhe.ibm.com/ibmdl/export/pub/software/websphere/wasdev/license/base_ilan/ilan/19.0.0.2/lafiles/en.html
2019-03-15T08:19:47.886158936Z [AUDIT   ] CWWKG0093A: Processing configuration drop-ins resource: /opt/ibm/wlp/usr/servers/defaultServer/configDropins/defaults/keystore.xml
2019-03-15T08:19:50.782259872Z [AUDIT   ] CWWKZ0058I: Monitoring dropins for applications.
2019-03-15T08:19:54.029871485Z [AUDIT   ] CWWKT0016I: Web application available (default_host): http://70a7c9c472d6:80/
2019-03-15T08:19:54.033891368Z [AUDIT   ] CWWKZ0001I: Application acmeair-monolithic started in 2.284 seconds.
2019-03-15T08:19:54.138431716Z [AUDIT   ] CWWKF0012I: The server installed the following features: [managedBeans-1.0, servlet-3.1, jndi-1.0, json-1.0, cdi-1.2, websocket-1.1, jaxrs-2.0, jaxrsClient-2.0].
2019-03-15T08:19:54.139383718Z [AUDIT   ] CWWKF0011I: The server defaultServer is ready to run a smarter planet.
```

Here the time take for startup can be obtained by `08:19:54.139383718-08:19:46.645067700` which is approximately `7.5 seconds`.

## Using CRIU

This project shows how to incorporate CRIU into the mix and use it to startup AcmeAir real quick.

### Idea

Basic idea is to incorporate the checkpoint of the application in the docker image itself, so that when a new container is started, the application can be restored from the checkpoint. This way it won't have to go through the startup process.

### Scripts

To achieve this, we need to do perform same steps as above to bring up the AcmeAir application.\
Once our server is up, we need to perform following additional steps:\
1. Checkpoint the server using CRIU.
2. Commit the docker container to create new image which would have the checkpoint.
3. To start the AcmeAir application create new container using the new image and restore the application from the checkpoint.

All the above initial steps to start up the AcmeAir app, checkpoint it and committing the container are automated in script `create_checkpoint_image.sh`. The last step is covered by `restore_from_checkpoint.sh`.

So, to generate the new docker image with AcmeAir application checkpoint, run:
`$ ./create_checkpoint_image.sh`

On successful completion, it generates a new docker image with name `acmeair_liberty_checkpoint`.
To start the AcmeAir application using `acmeair_liberty_checkpoint`, run:
`$ ./restore_from_checkpoint.sh`

You should now be able to access `http://localhost/`.
